package com.vihanga.eEducate.utility;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.JWTVerifier;
import com.vihanga.eEducate.constant.SecurityConstant;
import com.vihanga.eEducate.domain.HigherStaffPrincipal;

import static com.auth0.jwt.algorithms.Algorithm.HMAC512;

@Component
public class JWTTokenPorvider {

	//Bring the secret.
//	@Value("${jwt.secret}")
	private static final String secret = "aiahsduiahsdohqwdnauchuiwqoidjaojdpasdiuweyiihdsidufwuefsdhsdjfuqwndasiuh";
	
//	
//	Story - 
//	When user try to access to our resources, he comes with the JWT token. And its has all the authorities that user have to use this system. So take all those
//	authorities from token and check those authorities.
//	
//	1. Get all claims that user have, and those claims are given by the admin, when he register that user at this system. It means, those claims are at the database.
//	   
//	use - getClaimsFromUser() method.
//	
//	2. Using those claims, create the token which is pass to user.
//	
//	use - generateJwtToken() method.
//	
//	3. Now we can generate token. When a registerd user is trying to login this system, this will generate the token, and it has all the authorities that user was claimed.
//	   So we have to get those claimed authorities from token. For this process, there are some sub processers.
//	   
//	   i)   Verify the jwt token.
//
//		    Check the token that user have for acceess to our system ,whether that was generated by this application or not.
//		  
//		    use - getJWTVerifier()
//		  
//	   ii)  Get the claimed authorities from the token.
//
//		    use - getClaimsFromToken()
//		  
//	
//	   iii) Allow to user to access our resourses with thire permissions(view data, edit data, delete data) based on claimed
//			authorities that we a get from the ii) step
//
//			use - grantedAuthorities()
//

	
	
	//method to generate the token
	public String generateJwtToken(HigherStaffPrincipal higherStaffPrincipal) {
		//HigherStaffPrincipal class is check the credentials and authorizations are correct from the database.
		
		String[] claims = getClaimsFromUser(higherStaffPrincipal);//All permissions and authorities
		//token
		return JWT.create().withIssuer(SecurityConstant.VIHANGA_PRODUCTION)
				.withAudience(SecurityConstant.GET_VP_ADMINISTRATION)
				.withIssuedAt(new Date())
				.withSubject(higherStaffPrincipal.getUsername())
				.withArrayClaim(SecurityConstant.AUTHORITIES, claims)
				.withExpiresAt(new Date(System.currentTimeMillis() + SecurityConstant.EXPIRATION_TIME))
				.sign(HMAC512(secret.getBytes()));
	}

	//Allow to user to access our recourses with their permissions(view data, edit data, delete data) based on claimed
	//authorities that we a get from 'getClaimsFromToken()' method.			
	public List<GrantedAuthority> getAuthorities(String token){
		String[] claims = getClaimsFromToken(token);
		return Arrays.stream(claims).map(SimpleGrantedAuthority::new).collect(Collectors.toList());
		//stream - loop over collection
	}
	
	//If the received token is correct we have to tell spring security to get the authentication of the user and set it to spring security context.
	
	//spring security context - is used to store the details of the current authenticated user, also known as principle. If we have to get username or any other user details,
	//we have to go to the security context first.
	public Authentication getAuthentication(String username, List<GrantedAuthority> authorities, HttpServletRequest httpServletRequest) {
		UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(username, null, authorities);
		authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(httpServletRequest)); // set authenticated user details in security context.
		return authenticationToken;
	}
	
	//Check that received token is valid or not. (Username should not empty, and token should not expired token).
	public boolean isTokenValid(String username, String token) {
		JWTVerifier verifier = getJWTVerifier();

		return StringUtils.isNotEmpty(username) && !isTokenExpired(verifier, token);
	}
	
	//Get the value of the "sub" claim, or null if it's not available.
	public String getSubject(String token) {
		JWTVerifier verifier = getJWTVerifier();
		return verifier.verify(token).getSubject();
	}
	
	
	//Check the token is expired.
	private boolean isTokenExpired(JWTVerifier verifier, String token) {
		Date expiration = verifier.verify(token).getExpiresAt();
		return expiration.before(new Date());
	}

	//Get the value of the "audience" claim, or null if it's not available.
	private String[] getClaimsFromToken(String token) {
		
		JWTVerifier verifier = getJWTVerifier();
		return verifier.verify(token).getClaim(SecurityConstant.AUTHORITIES).asArray(String.class);
	}

	//verify the jwt token.
	private JWTVerifier getJWTVerifier() {
		JWTVerifier verifier;
		try {
			Algorithm algorithm = HMAC512(secret);
			verifier = JWT.require(algorithm).withIssuer(SecurityConstant.VIHANGA_PRODUCTION).build();
			System.out.println("Verifier is: " +verifier);
		} catch (JWTVerificationException e) {
			throw new JWTVerificationException(SecurityConstant.TOKEN_CANNOT_BE_VERIFIED);
			//In here we can throw 'e' as an exception. But in here I don't use it, instead of that, I create
			//new exception, because when I throw 'e', then user can see inner processes in this exception.
			//That why I create my own exception. 'throw new JWTVerificationException(SecurityConstant.TOKEN_CANNOT_BE_VERIFIED);' 
		}
		
		return verifier;
	}

	//Get all permissions and authorities for a user from database ,using HigherStaffPrincipal class.
	private String[] getClaimsFromUser(HigherStaffPrincipal higherStaffPrincipal) {
		
		List<String> authorities = new ArrayList<String>();
		//get all authorities by using 'getAuthorities()' method which is in 'HigherStaffPrincipal' class
		//and add into 'authorities' list.
		for(GrantedAuthority grantedAuthority : higherStaffPrincipal.getAuthorities()) {
			authorities.add(grantedAuthority.getAuthority());
		}
		return authorities.toArray(new String[0]);
		//'new String[0]' means we can get/return back authorities as a string[]/array.
	}
}
